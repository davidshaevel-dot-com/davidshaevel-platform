# ==============================================================================
# Observability Module - Main Configuration
# ==============================================================================
#
# This module provisions infrastructure for the observability stack:
# - S3 bucket for Prometheus configuration storage
# - EFS file system for Prometheus TSDB data persistence
# - EFS mount targets for high availability across multiple AZs
# - Security groups for EFS NFS access
# - IAM policies for S3 and EFS access from ECS tasks
#
# Phase 3 of TT-25: EFS file systems and supporting infrastructure
#
# Architecture:
# 1. Prometheus config rendered by Terraform → S3 bucket
# 2. ECS init container syncs S3 → EFS (one-time per task start)
# 3. Prometheus container reads config from EFS, writes data to EFS
# 4. EFS provides persistent storage across task restarts

locals {
  name_prefix = "${var.environment}-${var.project_name}"

  common_tags = merge(
    var.tags,
    {
      Module      = "observability"
      Environment = var.environment
      Project     = var.project_name
      ManagedBy   = "Terraform"
    }
  )
}

# ==============================================================================
# S3 Bucket for Prometheus Configuration
# ==============================================================================

# S3 bucket to store rendered Prometheus configuration files
# Config is generated by Terraform from prometheus.yml.tpl template
# and synced to EFS by init container on task startup
resource "aws_s3_bucket" "prometheus_config" {
  bucket = "${local.name_prefix}-prometheus-config"

  tags = merge(
    local.common_tags,
    {
      Name    = "${local.name_prefix}-prometheus-config"
      Purpose = "Prometheus configuration storage"
    }
  )
}

# Enable versioning to track config changes over time
resource "aws_s3_bucket_versioning" "prometheus_config" {
  count  = var.enable_config_bucket_versioning ? 1 : 0
  bucket = aws_s3_bucket.prometheus_config.id

  versioning_configuration {
    status = "Enabled"
  }
}

# Enable encryption at rest with AWS-managed keys
resource "aws_s3_bucket_server_side_encryption_configuration" "prometheus_config" {
  bucket = aws_s3_bucket.prometheus_config.id

  rule {
    apply_server_side_encryption_by_default {
      sse_algorithm = "AES256"
    }
  }
}

# Block all public access to config bucket
resource "aws_s3_bucket_public_access_block" "prometheus_config" {
  bucket = aws_s3_bucket.prometheus_config.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# Lifecycle policy to expire old config versions
resource "aws_s3_bucket_lifecycle_configuration" "prometheus_config" {
  count  = var.config_bucket_lifecycle_days > 0 ? 1 : 0
  bucket = aws_s3_bucket.prometheus_config.id

  rule {
    id     = "expire-old-versions"
    status = "Enabled"

    noncurrent_version_expiration {
      noncurrent_days = var.config_bucket_lifecycle_days
    }
  }
}

# ==============================================================================
# EFS File System for Prometheus Data
# ==============================================================================

# EFS file system for Prometheus TSDB data persistence
# Stores metrics data across ECS task restarts
# Multi-AZ for high availability
resource "aws_efs_file_system" "prometheus" {
  count = var.enable_prometheus_efs ? 1 : 0

  # Performance configuration
  performance_mode = var.prometheus_efs_performance_mode
  throughput_mode  = var.prometheus_efs_throughput_mode

  # Encryption at rest with AWS-managed KMS key
  encrypted = var.enable_efs_encryption

  # EFS Lifecycle policies:
  # 1. Transition files to Infrequent Access (IA) storage after a configured
  #    number of days (`var.efs_transition_to_ia_days`) to reduce storage costs.
  # 2. Transition files back to Standard storage from IA on the first access
  #    to ensure performance for active data.
  lifecycle_policy {
    transition_to_ia = "AFTER_${var.efs_transition_to_ia_days}_DAYS"
  }

  lifecycle_policy {
    transition_to_primary_storage_class = "AFTER_1_ACCESS"
  }

  tags = merge(
    local.common_tags,
    {
      Name    = "${local.name_prefix}-prometheus-data"
      Purpose = "Prometheus TSDB data persistence"
    }
  )
}

# ==============================================================================
# EFS Mount Targets
# ==============================================================================

# Create EFS mount target in each private app subnet for multi-AZ availability
# Allows ECS tasks in any AZ to access the file system
resource "aws_efs_mount_target" "prometheus" {
  count = var.enable_prometheus_efs ? length(var.private_app_subnet_ids) : 0

  file_system_id  = aws_efs_file_system.prometheus[0].id
  subnet_id       = var.private_app_subnet_ids[count.index]
  security_groups = [aws_security_group.efs[0].id]
}

# ==============================================================================
# EFS Security Group
# ==============================================================================

# Security group for EFS mount targets
# Allows NFS traffic (port 2049) from Prometheus ECS tasks
resource "aws_security_group" "efs" {
  count = var.enable_prometheus_efs ? 1 : 0

  name_prefix = "${local.name_prefix}-efs-"
  description = "Security group for Prometheus EFS mount targets"
  vpc_id      = var.vpc_id

  tags = merge(
    local.common_tags,
    {
      Name = "${local.name_prefix}-efs-sg"
    }
  )

  lifecycle {
    create_before_destroy = true
  }
}

# Ingress rule: Allow NFS (port 2049) from Prometheus security group
# Security groups are stateful - this ingress rule automatically allows return traffic
# No explicit egress rule needed for EFS mount targets (passive endpoints)
resource "aws_vpc_security_group_ingress_rule" "efs_nfs_from_prometheus" {
  count = var.enable_prometheus_efs ? 1 : 0

  security_group_id            = aws_security_group.efs[0].id
  description                  = "Allow NFS from Prometheus ECS tasks"
  referenced_security_group_id = var.prometheus_security_group_id
  from_port                    = 2049
  to_port                      = 2049
  ip_protocol                  = "tcp"

  tags = merge(
    local.common_tags,
    {
      Name = "efs-nfs-from-prometheus"
    }
  )
}

# ==============================================================================
# IAM Policy for S3 Config Access
# ==============================================================================

# IAM policy document for S3 config access
# Allows ECS tasks to read Prometheus config from S3
data "aws_iam_policy_document" "prometheus_s3_config_access" {
  statement {
    sid    = "AllowPrometheusConfigRead"
    effect = "Allow"

    actions = [
      "s3:GetObject",
      "s3:GetObjectVersion",
    ]

    resources = [
      "${aws_s3_bucket.prometheus_config.arn}/*",
    ]
  }

  statement {
    sid    = "AllowBucketList"
    effect = "Allow"

    actions = [
      "s3:ListBucket",
    ]

    resources = [
      aws_s3_bucket.prometheus_config.arn,
    ]
  }
}

# IAM policy for Prometheus task role
# Attach this to the Prometheus ECS task role in compute module
resource "aws_iam_policy" "prometheus_s3_config_access" {
  name_prefix = "${local.name_prefix}-prometheus-s3-config-"
  description = "Allow Prometheus ECS tasks to read configuration from S3"
  policy      = data.aws_iam_policy_document.prometheus_s3_config_access.json

  tags = merge(
    local.common_tags,
    {
      Name = "${local.name_prefix}-prometheus-s3-config-policy"
    }
  )
}
